TEST = None

MODE = None
PIN = None
ACTUAL_QUESTION = None
TOTAL_QUESTIONS = None
LEFT_TIME = None

CONNECTED_TOKEN = {}

TEMP_PLAYER_ANSWERS = {}
TEMP_PLAYER_RESULTS = {}
TEMP_GAME = None

async def cuenta_atras(websocket: WebSocket, seconds: int = 3):
	global MODE, LEFT_TIME

	for i in range(seconds, 0, -1):
		message = json.dumps({"MODE": MODE, "STARTS_IN": i})
		await websocket.send_text(message)
		await asyncio.sleep(1)

	for i in range(LEFT_TIME, 0, -1):
		message = json.dumps({"MODE": MODE, "LEFT_TIME": i})
		await websocket.send_text(message)
		await asyncio.sleep(1)

async def get_test_for_ws(ID: int):

	test = session.query(Test).filter(Test.id == ID).first()
	if test is None:
		raise HTTPException(status_code=404, detail="Test no encontrado")

	questions_data = [
		JSON_Question_Output(
			id=question.id,
			test_id=question.test_id,
			title=question.title,
			image=question.image,
			questionType=question.questionType,
			allocatedTime=question.allocatedTime,
			questionOrder=question.questionOrder,
			weight=question.weight,
			answers=[
				JSON_Answer_Output(
					id=answer.id,
					question_id=answer.question_id,
					title=answer.title,
					isCorrect=answer.isCorrect
				) for answer in question.answers
			]
		) for question in test.questions
		]

	response = JSON_Test_Output(
		id=test.id, 
		title=test.title, 
		image=test.image, 
		archived=test.archived, 
		played=await count_games(test.id),
		createdAt=test.createdAt,
		updatedAt=test.updatedAt,
		questions=questions_data,
		games=None
	)

	return response

async def get_question_for_ws(number: int):
	global TEST, LEFT_TIME

	pregunta = TEST.questions[number]
	pregunta_sin_correcta = {
		"id": pregunta.id,
		"test_id": pregunta.test_id,
		"title": pregunta.title,
		"image": pregunta.image,
		"questionType": pregunta.questionType,
		"allocatedTime": pregunta.allocatedTime,
		"weight": pregunta.weight,
		"answers": [{"id": r.id, "question_id": r.question_id, "title": r.title} for r in pregunta.answers]
	}

	LEFT_TIME = pregunta.allocatedTime

	return pregunta_sin_correcta



async def tx_messages(websocket: WebSocket, admin: bool):
	global MODE, PIN, CONNECTED_TOKEN, ACTUAL_QUESTION, TOTAL_QUESTIONS, LEFT_TIME
	while True:
		try:
			if MODE == "LOBBY":
				temp = []
				for token in CONNECTED_TOKEN:
					temp.append(PLAYERS[token])
				
				message = json.dumps({"MODE": MODE, "PIN": PIN, "PLAYERS": PLAYERS, "TOTAL_QUESTIONS": TOTAL_QUESTIONS})
				await websocket.send_text(message)

			elif MODE == "PLAYING":
				temp_question = await get_question_for_ws(ACTUAL_QUESTION)

				
				
				message = json.dumps({"MODE": MODE, "QUESTION": temp_question, "LEFT_TIME": LEFT_TIME, "ACTUAL_QUESTION": ACTUAL_QUESTION, "TOTAL_QUESTIONS": TOTAL_QUESTIONS})
				await websocket.send_text(message)

				await cuenta_atras(websocket, 5)
				
			elif MODE == "RESULTS":
				pass

			elif MODE == "END":
				pass

			
		except WebSocketDisconnect:
			break

async def rx_messages(websocket: WebSocket):
	global MODE, ACTUAL_QUESTION

	while True:
		try:
			if MODE == "LOBBY":
				pass

			elif MODE == "PLAYING":
				pass

			elif MODE == "RESULTS":
				pass
			
			elif MODE == "END":
				pass

			
		except WebSocketDisconnect:
			break

# WEBSOCKET DE JUEGO PARA ADMIN
@app.websocket("/test/{ID}/play/token={token}")
async def admin_websocket(token: str, ID: int, websocket: WebSocket):
	global MODE, PIN, TEST, CONNECTED_TOKEN, ACTUAL_QUESTION, TOTAL_QUESTIONS
	await websocket.accept()

	try:
		if not await is_admin(token):
			raise HTTPException(status_code=401, detail="No tienes permisos para acceder a esta sala")

		await websocket.send_text("Conexión establecida")

		TEST = await get_test_for_ws(ID)
		PIN = await generate_pin()

		ACTUAL_QUESTION = 0
		TOTAL_QUESTIONS = len(TEST.questions)

		MODE = "LOBBY"
		CONNECTED_TOKEN = []  # Asegúrate de inicializar esta variable correctamente

		send_task = asyncio.create_task(tx_messages_admin(websocket))
		receive_task = asyncio.create_task(rx_messages_admin(websocket))

		done, pending = await asyncio.wait(
			[send_task, receive_task],
			return_when=asyncio.FIRST_COMPLETED
		)

		for task in pending:
			task.cancel()

	except HTTPException as e:
		await websocket.send_text(str(e.detail))
		await websocket.close()

	except Exception as e:
		await websocket.send_text("Error en la conexión")
		await websocket.close()



async def tx_messages_player(websocket: WebSocket):
	global MODE, PIN, CONNECTED_TOKEN, TEST, ACTUAL_QUESTION, TOTAL_QUESTIONS
	while True:
		try:
			if MODE == "LOBBY":
				message = json.dumps({"MODE": MODE, "TOTAL_QUESTIONS": TOTAL_QUESTIONS})
				await websocket.send_text(message)

			elif MODE == "PLAYING":
				temp_question = await get_question_for_ws(ACTUAL_QUESTION)
				
				message = json.dumps({"MODE": MODE, "QUESTION": temp_question, "LEFT_TIME": LEFT_TIME, "ACTUAL_QUESTION": ACTUAL_QUESTION, "TOTAL_QUESTIONS": TOTAL_QUESTIONS})

			elif MODE == "RESULTS":
				pass
			
			elif MODE == "END":
				pass

			
		except WebSocketDisconnect:
			break

async def rx_messages_player(websocket: WebSocket, token: str):
	global MODE, ACTUAL_QUESTION, LEFT_TIME, TEMP_RESULTS

	while True:
		try:
			if MODE == "LOBBY":
				pass

			elif MODE == "PLAYING":
				pass

			elif MODE == "RESULTS":
				pass
			
			elif MODE == "END":
				pass

			
		except WebSocketDisconnect:
			break

# WEBSOCKET DE JUEGO PARA JUGADORES
@app.websocket("/play/pin={playerPIN}/token={token}")
async def player_websocket(websocket: WebSocket, playerPIN: int, token: str):
	global MODE, PIN, TEST, CONNECTED_TOKEN, ACTUAL_QUESTION, TOTAL_QUESTIONS
	await websocket.accept()
	try:
		if not token or token not in PLAYERS:
			await websocket.send_text("Fallo de sesión")
			await websocket.close()
		
		if playerPIN != PIN:
			await websocket.send_text("PIN incorrecto")
			await websocket.close()
		

		await websocket.send_text("Conexión establecida")

		CONNECTED_TOKEN.append(token)

		send_task = asyncio.create_task(tx_messages_player(websocket))
		receive_task = asyncio.create_task(rx_messages_player(websocket, token))

		done, pending = await asyncio.wait(
			[send_task, receive_task],
			return_when=asyncio.FIRST_COMPLETED
		)

		for task in pending:
			task.cancel()

	except HTTPException as e:
		await websocket.send_text(str(e.detail))
		await websocket.close()

	except Exception as e:
		await websocket.send_text("Error en la conexión")
		await websocket.close()